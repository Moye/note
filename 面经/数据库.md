# 数据库

## 1.数据库索引的数据结构

由于数据库一般存储在硬盘上，查询时候，需要进行IO操作，磁盘IO操作的时间成本远高于访问内存，约是访问内存的十万倍左右。因此需要使用B树或B+树这种高度较“矮”的树，而不用效率更高的二叉搜索树。注：树结构的高度决定了IO次数。

![b+树](../pic/database-index-b+tree-1.png)

如上图，就是一颗b+树，浅蓝色的块表示一个磁盘块，可以看出每个磁盘款包含几个数据项（深蓝色）和指针（黄色），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。

- 真实的数据存于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。
- 非叶子结点不保存真实的数据项，只存储指引搜索方向的数据项，如17、35并不是真实存在数据表中的。

### b+树节点结构

参考链接：[B+树](https://zh.wikipedia.org/wiki/B+%E6%A0%91#%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84)

![B+树](../pic/database-index-b+tree-wikipedia-2.png)

把键1-7连接到值 d1-d7 的B+树。链表（红色）用于快速顺序遍历叶子节点。树的分叉因子 ![b](https://wikimedia.org/api/rest_v1/media/math/render/svg/f11423fbb2e967f986e36804a8ae4271734917c3)=4。

- 每个结点通常表示为一组有序的元素和子指针
- 如果B+树的序数是m，则除了根以外的每个结点都包含至少 ![\lfloor m/2\rfloor ](https://wikimedia.org/api/rest_v1/media/math/render/svg/87be5eefdb8fa8b05d4e77a49222798c08e66318) 个元素最多m-1个元素，对任意的结点做多有m个子指针。
- 对于所有内部结点，子结点的数目总是比元素的数目多一个，因为所有叶子都在相同的高度上，结点通常不包含确定它们是叶子还是内部节点的方式
- 每个内部节点的元素充当分开它的[子树](https://zh.wikipedia.org/w/index.php?title=%E5%AD%90%E6%A0%91&action=edit&redlink=1)的分离值。例如，如果内部节点有三个子节点（或子树）则它必须有两个分离值或元素 *a*1 和 *a*2。在最左子树中所有的值都小于等于 *a*1，在中间子树中所有的值都在 *a*1 和 *a*2 之间((*a*1，*a*2]），而在最右子树中所有的值都大于 *a*2。

### b+树的查找过程

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

### b+树性质

1.通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有$h=㏒_{m+1}N$，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。**这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。**

2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

### B树和B+树

####B树

性质：

- 任意非叶子节点最多只有M个儿子，且M>2;
- 根节点的儿子书[2, M]；
- 根节点以外的非叶子节点的儿子数位[M/2, M]，向上取整；
- 非叶子节点的关键字个数 = 儿子数 - 1；
- 所有叶子节点位于同一层；
- k个关键字把节点拆成k+1段，分别指向k+1个儿子，同事满足查找树的大小关系

特征：

- 关键字集中分布在整棵树中；
- 任何一个关键字出现且只出现在一个节点中；
- 搜索有可能在非叶子节点结束；
- 其搜索性能等价于在关键字全集内一次二分查找；

#### b+树

m阶b+树特征：

- 有n颗子树的非叶子节点含有n个关键字（b树为n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。
- 所有叶子节点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子节点本身关键字的大小自小而大顺序链接。
- 所有非叶子节点可以看成是索引部分，节点中仅含有其子树中的最大（或最小）关键字。
- 通常在b+树上有两个头指针，一个指向根节点，一个指向关键字最小的叶子节点
- 同一个数字会在不同的节点中重复出现，根节点的最大元素就是b+树的最大元素。

b+树相比b树的查询优势：

- b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
- b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
- 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历

参考链接：

[深入理解数据库索引原理](https://www.jianshu.com/p/814c1675361c)

[b树和b+树的区别](https://blog.csdn.net/login_sonata/article/details/75268075)

[b树和b+树的区别2](https://blog.csdn.net/login_sonata/article/details/75268075)